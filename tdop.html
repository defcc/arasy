<!DOCTYPE html>
<html>
<head>
    <script src="temp/precedence.js"></script>
    <script src="temp/scanner.js"></script>
    <script src="temp/expressiontest.js"></script>
    <script src="lexer.js" ></script>
</head>
<body>

</body>
</html>

<script>

function makeArray( obj ){
    if ( Object.prototype.toString.call( obj ) == '[object Array]' ) {
        return obj;
    } else {
        return [obj];
    }
}

var prefixOperatorParser = function( expressionParser, token ){
    var operand = expressionParser.parse( getPrecedenceByToken( token) );
    return {
        type: 'UnaryExpression',
        operator: token.val,
        prefix: true,
        argument: operand
    }
};

var infixOperatorParser = function( expressionParser, left,  token ){
    var operand = expressionParser.parse( getPrecedenceByToken( token ) );
    return {
        type: 'BinaryExpression',
        operator: token.val,
        infix: true,
        left: left,
        right: operand
    }
};

var postfixOperatorParser = function( expressionParser, left, token ){
    return {
        type: 'updateExpression',
        operator: token.val,
        prefix: false,
        argument: left
    }
};

var identifyParser = function( expressionParser, token ){
    return {
        type: 'Identifier',
        name: token.val
    }
};

var literalParser = function( expressionParser, token ){
    return {
        type: 'Literal',
        value: token.val
    }
};

var thisParser = function( expressionParser, token ){
    return {
        type: 'thisExpression'
    }
};

//group parser for (

var groupParser = function( expressionParser, token ){
    var groupExp = expressionParser.parse( getPrecedenceByToken( token ) );
    var rightParen = tokenList.consume();
    return groupExp;
    //TODO check rightParen is just ")"
    return {
        type: 'GroupExpression',
        argument: groupExp,
        prefix: true
    }
};

//arrayExpressionParser for [
var arrayParser = function( expressionParser, token ){
    var rs = [];

    var nextToken = tokenList.lookAhead();
    if ( nextToken.val != ']' ) {
        rs = expressionParser.parse(0);
    }
    //must be right bracket
    tokenList.consume();

    return {
        type: 'ArrayExpression',
        elements: makeArray( rs )
    }
};

//parse a[b]
var memberExpressionParser = function( expressionParser, left, token ){

    var propertyArg = expressionParser.parse(0);

    tokenList.consume();

    return {
        type: 'MemberExpression',
        object: left,
        property: propertyArg
    }
};

//parse a = b = c
var assignParser = function( expressionParser, left, token ){
    var operand = expressionParser.parse( getPrecedenceByToken( token ) - 1 );

    return {
        type: 'assignExpression',
        operator: '=',
        infix: true,
        left: left,
        right: operand
    }
};

var paramsListParser = function(){
    var rs = [],
            item;

    tokenList.consume();
    //match({type: 'punctuator', value: '('}, this.nextToken());

    var peekToken = tokenList.lookAhead();
    if( peekToken.type == tokensMap.identify ){
        while( (item = tokenList.consume()).type == tokensMap.identify ){
            rs.push({
                type: 'Identifier',
                name: item.val
            });
            var nextToken = tokenList.lookAhead();
            if(nextToken.val != ','){
                break;
            }else{
                tokenList.consume();
            }
        }
    }
    //match({type: 'punctuator', value: ')'}, this.nextToken());
    tokenList.consume();
    return rs;
};

//parse a(a+b, c+d);
var argumentsParser = function( expressionParser ){
    var rs = [];

    //consume left paren;
    tokenList.consume();
    var nextToken = tokenList.lookAhead();
    if ( nextToken.val != ')' ) {
        rs = expressionParser.parse(0);
    }
    tokenList.consume();
    return rs;

};

//function identifierName(opt) ( arguments )
var functionParser = function( expressionParser, token ){
    var identifyerName = null;
    var lookaheadToken = tokenList.lookAhead();
    var isIdentifierNameToken = lookaheadToken.type == tokensMap.identify;
    if ( isIdentifierNameToken ) {
        identifyerName = {
            type: 'Identifier',
            name: lookaheadToken.val
        };
        tokenList.consume();
    }
    var params = paramsListParser();

    return {
        type: 'functionExpression',
        id: identifyerName,
        params: params
    }

};

//new expression
var newParser = function( expressionParser, token ){
    var identify = tokenList.consume();

    //check arguments;
    var argumentsParam = [];
    var leftParen = tokenList.lookAhead();
    if ( leftParen.val == '(' ) {
        argumentsParam = argumentsParser( expressionParser );
    }

    return {
        "type": 'newExpression',
        "callee": identify,
        "arguments": argumentsParam
    }
};

//infix parser
//a+b,c
var commaParser = function( expressionParser,  left, token ){
    var rs = [ left ];
    var expressionItem;
    while( expressionItem = expressionParser.parse( getPrecedenceByToken( token ) ) ) {
        rs.push( expressionItem );
        var nextToken = tokenList.lookAhead();
        if ( nextToken.val == ',' ) {
            tokenList.consume();
        } else {
            break;
        }
    }
    return rs;
};

//objectExpressionParser
var objectExpressionParser = function( expressionParser, token ){
    var objectRs = {
        type: "ObjectExpression",
        properties: []
    };

    objectRs.properties = parseObjectExpressionElements();

    //consume }
    tokenList.consume();

    return objectRs;


    function parseObjectExpressionElements(){
        var rs = [],
            item;

        while( item = parseObjectItem() ){
            rs.push( item );

            var peekToken = tokenList.lookAhead();
            if( peekToken.val != ',' ){
                break;
            }else{
                tokenList.consume();
            }
        }
        return rs;
    }

    function parseObjectItem(){
        var rs = {};

        rs.type = 'Property';
        rs.key = tokenList.consume();
        //consume :
        tokenList.consume();

        rs.value = expressionParser.parse(10);
        rs.kind = "init";

        return rs;
    }
};

var expressionParser = {
    prefixParselet: {},
    infixParselet: {},
    registerPrefix: function( tokenType, parselet ){
        this.prefixParselet[ tokenType ] = parselet;
    },

    registerPrefixOperator: function ( tokenType ) {
        this.prefixParselet[ tokenType ] = prefixOperatorParser;
    },

    registerInfix: function( tokenType, parselet ){
        this.infixParselet[ tokenType ] = parselet;
    },

    registerInfixOperator: function ( tokenType ) {
        this.infixParselet[ tokenType ] = infixOperatorParser;
    },

    parse: function( precedence ) {
        var token = tokenList.consume();
        if ( token.type == 'eof' ) {
            return;
        }
        var prefixParser = this.prefixParselet[ token.type ];
        var left = prefixParser( this, token );

        while ( precedence < this.getPrecedence() ) {
            var token = tokenList.consume();
            var infixParser = this.infixParselet[ token.type ];
            left = infixParser( this, left, token );
        }
        return left;
    },
    getPrecedence: function (  ) {
        var nextToken = tokenList.lookAhead();
        var precedence = getPrecedenceByToken( nextToken );
        if ( getPrecedenceByToken( nextToken ) ) {
            return precedence;
        }
        return 0;
    }
};

function getPrecedenceByToken( token ){
    return precedence[ token.type ];
}

expressionParser.registerPrefixOperator(operatorTokenMap.deleteOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.voidOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.unaryOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.unarynegationOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.typeofOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.incrementOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.decrementOperator);

expressionParser.registerPrefix(operatorTokenMap.this, thisParser);
expressionParser.registerPrefix(operatorTokenMap.identify, identifyParser);
expressionParser.registerPrefix(operatorTokenMap.number, literalParser);
expressionParser.registerPrefix(operatorTokenMap.groupOperator, groupParser);
expressionParser.registerPrefix(operatorTokenMap.arrayOperator, arrayParser);
expressionParser.registerPrefix(operatorTokenMap.functionExpression, functionParser);

expressionParser.registerPrefix(operatorTokenMap.newOperator, newParser);

expressionParser.registerPrefix(operatorTokenMap.braces, objectExpressionParser);


expressionParser.registerInfixOperator(operatorTokenMap.additionOperator);
expressionParser.registerInfixOperator(operatorTokenMap.mutliOperator);
expressionParser.registerInfixOperator(operatorTokenMap.divOperator);
expressionParser.registerInfixOperator(operatorTokenMap.subtractionOperator);
expressionParser.registerInfixOperator(operatorTokenMap.dotOperator);


expressionParser.registerInfix(operatorTokenMap.assignmentOperator, assignParser);
expressionParser.registerInfix(operatorTokenMap.arrayOperator, memberExpressionParser);

expressionParser.registerInfix(operatorTokenMap.incrementOperator, postfixOperatorParser);
expressionParser.registerInfix(operatorTokenMap.decrementOperator, postfixOperatorParser);

expressionParser.registerInfix(operatorTokenMap.commaOperator, commaParser);

console.log(expressionParser.parse(0));

</script>