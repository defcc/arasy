<!DOCTYPE html>
<html>
<head>
    <script src="lexer.js" ></script>
</head>
<body>

</body>
</html>

<script>

/*
*
--------------------------------------
  operator  |  precedence   |    ex
--------------------------------------
   dot      |      30       |    .
   typeof   |      20       |    typeof
   void     |      19       |    void
   mutli    |      18       |    x
   div      |      18       |    /
   plus     |      17       |    +
   minus    |      17       |    -


   (        |      2        |    groupOperator
   [        |      2        |    arrayOperator
            |               |


* */


var types = [
    'dotOperator',
    'typeofOperator',
    'deleteOperator',
    'voidOperator',
    'identify',
    'plusOperator',
    'mutliOperator',
    'divOperator',
    'minusOperator',
    'groupOperator',
    'arrayOperator'

];
function makeObject( array ){
    var obj = {};
    for ( var i = 0; i < array.length; i++ ) {
        obj[ array[i] ] = array[i];
    }
    return obj;
}

var operatorTokenMap = makeObject( types );




var testTokenList = [ {
    type: operatorTokenMap.arrayOperator,
    val: '[',
    precedence: 2
}, {
    type: operatorTokenMap.arrayOperator,
    val: '[',
    precedence: 2
}, {
    type: operatorTokenMap.identify,
    val: 'a',
    precedence: 1
}, {
    type: operatorTokenMap.arrayOperator,
    val: ']',
    precedence: 2
}, {
    type: operatorTokenMap.arrayOperator,
    val: ']',
    precedence: 2
}, {
    type: operatorTokenMap.arrayOperator,
    val: '[',
    precedence: 2
}, {
    type: operatorTokenMap.identify,
    val: 'a',
    precedence: 1
}, {
    type: operatorTokenMap.arrayOperator,
    val: ']',
    precedence: 2
}];


var tokenList = {
    index: 0,
    list: [{
        type: 'eof',
        val: 'eof'
    }],
    consume: function(){
        if ( this.eof() ) {
            return this.eof();
        }
        return tokenList.list[ this.index++ ];
    },
    lookAhead: function(){
        if ( this.eof() ) {
            return this.eof();
        }
        return tokenList.list[ this.index ];
    },
    eof: function(){
        if ( this.index >= tokenList.list.length - 1 ) {
            return {
                type: 'eof',
                val: 'eof'
            }
        }
    }
};




makeTestToken(tokenList.list, testTokenList);

function makeTestToken( source, testTokens ){
    var testTokenLen = testTokens.length;
    for ( var i = 0; i < testTokenLen; i++ ) {
        source.unshift( testTokens.pop() );
    }
}

var prefixOperatorParser = function( expressionParser, token ){
    var operand = expressionParser.parse( token.precedence );
    return {
        type: 'UnaryExpression',
        operator: token.val,
        prefix: true,
        argument: operand
    }
};

var infixOperatorParser = function( expressionParser, left,  token ){
    var operand = expressionParser.parse( token.precedence );
    return {
        type: 'BinaryExpression',
        operator: token.val,
        infix: true,
        left: left,
        right: operand
    }
};

var identifyParser = function( expressionParser, token ){
    return {
        type: 'Identifier',
        name: token.val
    }
};

//group parser for (

var groupParser = function( expressionParser, token ){
    var groupExp = expressionParser.parse( token.precedence );
    var rightParen = tokenList.consume();
    //TODO check rightParen is just ")"
    return {
        type: 'GroupExpression',
        argument: groupExp,
        prefix: true
    }
};

//arrayParser for [
var arrayParser = function( expressionParser, token ){
    var arrayExp = expressionParser.parse( token.precedence );
    var rightParen = tokenList.consume();

    return {
        type: 'ArrayExpression',
        argument: arrayExp,
        prefix: true
    }
};

//parse a[b]

var valReadParser = function( expressionParser, left, token ){
    var operand = expressionParser.parse( token.precedence );
    var rightParen = tokenList.consume();

    return {
        type: 'ValReadExpression',
        operator: '[',
        infix: true,
        left: left,
        right: operand
    }
};

var expressionParser = {
    prefixParselet: [],
    infixParselet: [],
    registerPrefix: function( tokenType, parselet ){
        this.prefixParselet[ tokenType ] = parselet;
    },

    registerPrefixOperator: function ( tokenType ) {
        this.prefixParselet[ tokenType ] = prefixOperatorParser;
    },

    registerInfix: function( tokenType, parselet ){
        this.infixParselet[ tokenType ] = parselet;
    },

    registerInfixOperator: function ( tokenType ) {
        this.infixParselet[ tokenType ] = infixOperatorParser;
    },

    parse: function( precedence ) {
        var token = tokenList.consume();
        if ( token.type == 'eof' ) {
            return;
        }
        var prefixParser = this.prefixParselet[ token.type ];
        var left = prefixParser( this, token );

        while ( precedence < this.getPrecedence() ) {
            var token = tokenList.consume();
            var infixParser = this.infixParselet[ token.type ];
            left = infixParser( this, left, token );
        }
        return left;
    },
    getPrecedence: function (  ) {
        var nextToken = tokenList.lookAhead();
        if ( nextToken.precedence ) {
            return nextToken.precedence;
        }
        return 0;
    }
};

expressionParser.registerPrefixOperator(operatorTokenMap.deleteOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.voidOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.plusOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.minusOperator);
expressionParser.registerPrefixOperator(operatorTokenMap.typeofOperator);
expressionParser.registerPrefix(operatorTokenMap.identify, identifyParser);
expressionParser.registerPrefix(operatorTokenMap.groupOperator, groupParser);
expressionParser.registerPrefix(operatorTokenMap.arrayOperator, arrayParser);


expressionParser.registerInfixOperator(operatorTokenMap.plusOperator);
expressionParser.registerInfixOperator(operatorTokenMap.mutliOperator);
expressionParser.registerInfixOperator(operatorTokenMap.divOperator);
expressionParser.registerInfixOperator(operatorTokenMap.minusOperator);
expressionParser.registerInfixOperator(operatorTokenMap.dotOperator);
expressionParser.registerInfix(operatorTokenMap.arrayOperator, valReadParser);

console.log(expressionParser.parse(0));

</script>